/*
 * (C) Copyright 2009 Pål Driveklepp
 *
 * Written by: Pål Driveklepp <jalla2000@gmail.com>
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <libgen.h>
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

#include <QObject>
#include <QTimer>
#include <QFile>
#include <QMessageBox>
#include <QIODevice>
#include <QTextStream>
#include <QMessageBox>

// The one and only entrypoint to the libspotify API
#include <spotify/api.h>

#include "spotworker.hpp"
#include "alsaworker.hpp"
#include "soundsaver.hpp"

/* --- Data --- */
/// The application key is specific to each project, and allows Spotify
/// to produce statistics on how our service is used.
extern const uint8_t g_appkey[];
/// The size of the application key.
extern const size_t g_appkey_size;

//callback functions for libspotify
extern "C" void metadata_updated(sp_session *session);
extern "C" void session_ready(sp_session *session);
extern "C" void session_terminated(void);

extern "C" void connection_error(sp_session *session, sp_error error);
extern "C" void logged_in(sp_session *session, sp_error error);
extern "C" void logged_out(sp_session *session);
extern "C" void notify_main_thread(sp_session *session);
extern "C" void log_message(sp_session *session, const char *data);
extern "C" void loop(sp_session *session);
extern "C" void sigIgn(int signo);


static sp_session_callbacks g_callbacks = {
    &logged_in,
    &logged_out,
    &metadata_updated,
    &connection_error,
    NULL,
    &notify_main_thread,
    &music_delivery,
    &play_token_lost,
    &log_message
};

//The playlist container callbacks
/*
//TODO: USE OR REMOVE
static sp_playlistcontainer_callbacks pc_callbacks = {
	playlist_added,
	playlist_removed,
	NULL
};
*/

//The callbacks we are interested in for individual playlists.
static sp_playlist_callbacks pl_callbacks = {
	&tracks_added,
	&tracks_removed,
	&tracks_moved,
	&playlist_renamed,
	NULL,
	NULL
};



bool SpotWorker::instanceFlag = false;
SpotWorker* SpotWorker::workerInstance = NULL;

SpotWorker* SpotWorker::getInstance()
{
    if(! instanceFlag)
    {
        workerInstance = new SpotWorker();
        instanceFlag = true;
        return workerInstance;
    }
    else
    {
        return workerInstance;
    }
}

SpotWorker::SpotWorker(QObject *parent)
    : QObject(parent)
{

    totalFrames = 0;
    frameCounter = -1;
    //playing = false;

    printf("SpotWorker started\n");
    
}

int SpotWorker::start(QString username, QString password)
{
    sp_session_config config;
    sp_error error;
    
    //signal(SIGIO, SIG_IGN);
    //signal(SIGIO, &SpotWorker::sigIgn);
    
    // Always do this. It allows libspotify to check for
    // header/library inconsistencies.
    config.api_version = SPOTIFY_API_VERSION;
    
    // The path of the directory to store the cache. This must be specified.
    // Please read the documentation on preferred values.
    config.cache_location = "tmp";
    
    // The path of the directory to store the settings. This must be specified.
    // Please read the documentation on preferred values.
    config.settings_location = "tmp";
    
    // The key of the application. They are generated by Spotify,
    // and are specific to each application using libspotify.
    config.application_key = g_appkey;
    config.application_key_size = g_appkey_size;
    
    // This identifies the application using some
    // free-text string [1, 255] characters.
    config.user_agent = "spotify-session-example";
    
    // Register the callbacks.
    config.callbacks = &g_callbacks;
    
    error = sp_session_init(&config, &currentSession);
    
    if (SP_ERROR_OK != error) {
	fprintf(stderr, "failed to create session: %s\n",
		sp_error_message(error));
    }
    
    // Login using the credentials given on the command line.
    //printf("Logging in...\n");
    error = sp_session_login(currentSession, 
			     username.toUtf8().data(), 
			     password.toUtf8().data());
    
    printf("sp_session_login returned %d\n", error);

    if (SP_ERROR_OK != error) {
	fprintf(stderr, "failed to login: %s\n",
		sp_error_message(error));
    }
    
    eventTimer = new QTimer();
    connect(eventTimer, SIGNAL(timeout()), SLOT(processEvents()) );
    eventTimer->start( 3000 );
    watchDog = new QTimer();
    connect(watchDog, SIGNAL(timeout()), SLOT(streamingStopped()) );

    // TODO: find out what these two lines do, 
    // and why they are commented out
    //loop(session);
    //session_terminated();

    soundSaver = new SoundSaver();
    alsaWorker = new AlsaWorker();
    printf("Spotworker started with soundSaver and alsaWorker constructed\n");

    return 0; //TODO: return something else when stuff fail.

}

void SpotWorker::performSearch(QString query)
{
    //TODO: put query in string
    const QByteArray qba = query.toUtf8();
    const char *ss = qba.data();
    printf("Requesting search. Query: %s", ss);
    g_search = sp_search_create(currentSession, ss, 0, 100, search_complete, NULL);

    if (!g_search) {
	fprintf(stderr, "Clay Davis says: Sheeeet! Failed to start search!\n");
    }
}

//void SpotWorker::loadPlayer(sp_session *session, sp_track *track)
void SpotWorker::loadPlayer(sp_track *track, bool rip, SoundSaver::FileType type)
{
    totalFrames = sp_track_duration(track)*44;
    alsaWorker->audioFifoFlush();
    frameCounter = 0;
    //printf("Splitting output files...\n");
    
    closeFile();
    if(rip){
	saveFile(track, type);
	printf("Debug: bool received: true\n");
    }
    else
	printf("Debug: bool received: false\n");
    //printf("Loading the player...4real\n");
    sp_session_player_load(currentSession, track);
}
void SpotWorker::playPlayer(bool play)
{
    sp_error err = sp_session_player_play(currentSession, play);
    alsaWorker->pause(!play);
    err = err;
}
void SpotWorker::seekPlayer(int offset)
{
    sp_error err = sp_session_player_seek(currentSession, offset);
    err = err;
}
bool SpotWorker::isPlaying()
{
    return alsaWorker->isPlaying();
}
bool SpotWorker::isStreaming()
{
    return this->streaming;
}


void SpotWorker::processEvents()
{
    //printf("processEvents called!\n");
    int timeout = 1000;
    sp_session_process_events(currentSession, &timeout);
    eventTimer->setInterval(timeout);
}


/* ------------------------  BEGIN SESSION CALLBACKS  ---------------------- */
/**
 * This callback is called when the user was logged in, but the connection to
 * Spotify was dropped for some reason.
 *
 * @sa sp_session_callbacks#connection_error
 */
extern "C" void connection_error(sp_session *session, sp_error error)
{
    fprintf(stderr, "connection to Spotify failed: %s\n", sp_error_message(error));
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitConnectionErrorSignal(session, error);
}

//Emit QT-signal for spotify callback
void SpotWorker::emitConnectionErrorSignal(sp_session *session, sp_error error)
{
    printf("Emitting signal connectionError\n");
    emit connectionError(session, error);
}


/**
 * This callback is called when an attempt to login has succeeded or failed.
 *
 * @sa sp_session_callbacks#logged_in
 */
extern "C" void logged_in(sp_session *session, sp_error error)
{
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitLoggedInSignal(session, error);

    if (SP_ERROR_OK == error) {
	// Let us print the nice message...
	sp_user *me = sp_session_user(session);
	const char *my_name = (sp_user_is_loaded(me) ?
			       sp_user_display_name(me) :
			       sp_user_canonical_name(me));
	printf("Logged in to Spotify as user %s\n", my_name);
	session_ready(session);
    }
    
}

//Emit QT-signal for spotify callback
void SpotWorker::emitLoggedInSignal(sp_session *session, sp_error error)
{
    if (SP_ERROR_OK != error) {
	fprintf(stderr, "SpotWorker: Login failed: %s\n",
		sp_error_message(error));
    }
    else{
	
	emit loggedIn(session, error);

	sp_playlistcontainer *pc = sp_session_playlistcontainer(session);

	int i;
	int listCount = sp_playlistcontainer_num_playlists(pc);
	printf("%d playlists discovered\n", sp_playlistcontainer_num_playlists(pc));

	if(listCount > 0)
	    emit playListsDiscovered(pc);
	
	for (i = 0; i < sp_playlistcontainer_num_playlists(pc); ++i) {
	    sp_playlist *pl = sp_playlistcontainer_playlist(pc, i);
	    
	    //TODO: register callback
	    //sp_playlist_add_callbacks(pl, &pl_callbacks, NULL);
	    
	    //if (!strcasecmp(sp_playlist_name(pl), g_listname)) {
	    //    g_jukeboxlist = pl;
	    //    try_jukebox_start();
	    //}
	    printf("Playlist found: %s\n", sp_playlist_name(pl));
	}
	
	/*
	  if (!g_jukeboxlist) {
	  printf("jukebox: No such playlist. Waiting for one to pop up...\n");
	  fflush(stdout);
	  }
	*/
    }
}

/**
 * This callback is called when the session has logged out of Spotify.
 *
 * @sa sp_session_callbacks#logged_out
 */
extern "C" void logged_out(sp_session *session)
{
    //if (g_exit_code< 0)
    //	g_exit_code = 0;
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitLoggedOutSignal(session);   
    printf("Logged out of Spotify...\n");
}

//Emit QT-signal for spotify callback
void SpotWorker::emitLoggedOutSignal(sp_session *session)
{
    printf("Emitting signal loggedOut\n");
    emit loggedOut(session);
}


/**
 * This callback is called from an internal libspotify thread to ask us to
 * reiterate the main loop.
 *
 * The most straight forward way to do this is using Unix signals. We use
 * SIGIO. signal(7) in Linux says "I/O now possible" which sounds reasonable.
 *
 * @sa sp_session_callbacks#notify_main_thread
 */
extern "C" void notify_main_thread(sp_session *)
{
    //pthread_kill(g_main_thread, SIGIO);
    //printf("notify_main_thred called!\n");
}

extern "C" int music_delivery(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames)
{
    SpotWorker *sw = SpotWorker::getInstance();
    return sw->emitMusicDeliverySignal(session, format, frames, num_frames);
}
//Emit QT-signal for spotify callback
int SpotWorker::emitMusicDeliverySignal(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames)
{
    int framesEaten = alsaWorker->musicDelivery(session, format, frames, num_frames);
    frameCounter += framesEaten;
    //check if the song is buffered completely

    /* Check if end of song is reached
     * If the samplerate is 44.1kHz, we should get about 44100 frames per second.
     * This is approximately 44.1 samples per millisecond. If the difference
     * totalFrames-frameCouner < threshold, the song is probably buffered.
     * In addition, a timer is used for extra safety.
     */
    //printf("Frames left: %d", totalFrames - frameCounter);
    if(totalFrames - frameCounter > 100){
	watchDog->start(1000);
    }

    soundSaver->saveSound(frames, framesEaten);
    return framesEaten;
}

extern "C" void play_token_lost(sp_session *session)
{
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitPlayTokenLostSignal(session);
    printf("Emitting signal playTokenLost\n");
}
//Emit QT-signal for spotify callback
void SpotWorker::emitPlayTokenLostSignal(sp_session *session)
{
    emit playTokenLost(session);
}

/**
 * This callback is called for log messages.
 *
 * @sa sp_session_callbacks#log_message
 */
extern "C" void log_message(sp_session * /*session*/, const char *data)
{
	fprintf(stderr, "log_message: %s\n", data);
}



/**
 * A dummy function to ignore SIGIO.
 */
extern "C" void sigIgn(int signo)
{
    printf("sigIgn: %d\n", signo);
}




/**
 * Callback called when libspotify has new metadata available
 *
 * Not used in this example (but available to be able to reuse the session.c file
 * for other examples.)
 */
extern "C" void metadata_updated(sp_session *session)
{

    //dummy to avoid compile warning
    sp_session *jalla = session;
    jalla = jalla;


}

/**
 * Callback called when the session has successfully logged in
 *
 * This is where we start two browse requests; one artist and one album. They
 * will eventually call the album_complete() and artist_complete() callbacks.
 *
 * This
 */
extern "C" void session_ready(sp_session *session)
{
    printf("Session ready called!\n");

    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitSessionReadySignal(session);
}

//Emit QT-signal for spotify callback
void SpotWorker::emitSessionReadySignal(sp_session *session)
{
    //printf("Emitting signal sessionReady\n");
    emit sessionReady(session);
}

/**
 * Callback for libspotify
 *
 * @param browse    The browse result object that is now done
 * @param userdata  The opaque pointer given to sp_artistbrowse_create()
 */
extern "C" void search_complete(sp_search *search, void *userdata)
{
    //dummy to avoid compile warning
    void *jalla = userdata;
    jalla = jalla;
    
    SpotWorker *sw = SpotWorker::getInstance();

    //TODO: move these checks to signal receiver
    //TODO: why is *userdata not passed to signal?
    if (search && SP_ERROR_OK == sp_search_error(search)){
	//sw->print_search(search);
	sw->emitSearchCompleteSignal(search);
    }
    else{
	fprintf(stderr, "Failed to search: %s\n", sp_error_message(sp_search_error(search)));
	sw->emitSearchCompleteSignal(NULL);
    }
    //sp_search_release(sw->g_search);

    //terminate();
}

//Emit QT-signal for spotify callback
void SpotWorker::emitSearchCompleteSignal(sp_search *search)
{
    //printf("Emitting signal searchComplete\n");
    emit searchComplete(search);
}

/**
 * Callback called when the session has been terminated.
 */
extern "C" void session_terminated(void)
{
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitSessionTerminatedSignal();
}

//Emit QT-signal for spotify callback
void SpotWorker::emitSessionTerminatedSignal(void)
{
    printf("Emitting signal sessionTerminated\n");
    emit sessionTerminated();
}


/* --------------------  PLAYLIST CONTAINER CALLBACKS  --------------------- */
/**
 * Callback from libspotify, telling us a playlist was added to the playlist container.
 *
 * We add our playlist callbacks to the newly added playlist.
 *
 * @param  pc            The playlist container handle
 * @param  pl            The playlist handle
 * @param  position      Index of the added playlist
 * @param  userdata      The opaque pointer
 */
extern "C" void playlist_added(sp_playlistcontainer */*pc*/, sp_playlist *pl,
			       int /*position*/, void * /*userdata*/)
{
    printf("Playlist_added: %s\n", sp_playlist_name(pl));
    sp_playlist_add_callbacks(pl, &pl_callbacks, NULL);
    
    /*    if (!strcasecmp(sp_playlist_name(pl), g_listname)) {
	g_jukeboxlist = pl;
    }
    */
}

/**
 * Callback from libspotify, telling us a playlist was removed from the playlist container.
 *
 * This is the place to remove our playlist callbacks.
 *
 * @param  pc            The playlist container handle
 * @param  pl            The playlist handle
 * @param  position      Index of the removed playlist
 * @param  userdata      The opaque pointer
 */
extern "C" void playlist_removed(sp_playlistcontainer * /*pc*/, sp_playlist *pl,
				 int /*position*/, void * /*userdata*/)
{
	sp_playlist_remove_callbacks(pl, &pl_callbacks, NULL);
}



/* --------------------------  PLAYLIST CALLBACKS  ------------------------- */
/**
 * Callback from libspotify, saying that a track has been added to a playlist.
 *
 * @param  pl          The playlist handle
 * @param  tracks      An array of track handles
 * @param  num_tracks  The number of tracks in the \c tracks array
 * @param  position    Where the tracks were inserted
 * @param  userdata    The opaque pointer
 */
extern "C" void tracks_added(sp_playlist * /*pl*/, const sp_track ** /*tracks*/,
			     int num_tracks, int /*position*/, void * /*userdata*/)
{
    /*
	if (pl != g_jukeboxlist)
		return;
    */
	printf("%d tracks were added to a playlist\n", num_tracks);
	fflush(stdout);
}

/**
 * Callback from libspotify, saying that a track has been added to a playlist.
 *
 * @param  pl          The playlist handle
 * @param  tracks      An array of track indices
 * @param  num_tracks  The number of tracks in the \c tracks array
 * @param  userdata    The opaque pointer
 */
extern "C" void tracks_removed(sp_playlist * /*pl*/, const int * /*tracks*/,
			       int num_tracks, void * /*userdata*/)
{
    //int i, k = 0;
    
    /*
    if (pl != g_jukeboxlist)
        return;
    
    for (i = 0; i < num_tracks; ++i)
        if (tracks[i] < g_track_index)
            ++k;
    
    g_track_index -= k;
    */
    printf("%d tracks were removed from a playlist\n", num_tracks);
    fflush(stdout);
}

/**
 * Callback from libspotify, telling when tracks have been moved around in a playlist.
 *
 * @param  pl            The playlist handle
 * @param  tracks        An array of track indices
 * @param  num_tracks    The number of tracks in the \c tracks array
 * @param  new_position  To where the tracks were moved
 * @param  userdata      The opaque pointer
 */
extern "C" void tracks_moved(sp_playlist * /*pl*/, const int * /*tracks*/,
			     int num_tracks, int /*new_position*/, void * /*userdata*/)
{
    //TODO: Use more function parameters
    /*
	if (pl != g_jukeboxlist)
		return;
    */
	printf("%d tracks were moved around in a playlist\n", num_tracks);
	fflush(stdout);
}

/**
 * Callback from libspotify. Something renamed the playlist.
 *
 * @param  pl            The playlist handle
 * @param  userdata      The opaque pointer
 */
extern "C" void playlist_renamed(sp_playlist *pl, void * /*userdata*/)
{
	const char *name = sp_playlist_name(pl);

	/*
	if (!strcasecmp(name, g_listname)) {
	g_jukeboxlist = pl;
	g_track_index = 0;
	try_jukebox_start();
	} else if (g_jukeboxlist == pl) {
	*/
	printf("Current playlist renamed to \"%s\".\n", name);
	/*
	  g_jukeboxlist = NULL;
	  g_currenttrack = NULL;
	  sp_session_player_unload(g_sess);
	  }
	*/
}



/**
 * Print the given track title together with some trivial metadata
 *
 * @param  track   The track object
 */

/*
void SpotWorker::print_track(sp_track *track)
{
	int duration = sp_track_duration(track);

	printf("  Track \"%s\" [%d:%02d] has %d artist(s), %d%% popularity\n",
		sp_track_name(track),
		duration / 60000,
		(duration / 1000) / 60,
		sp_track_num_artists(track),
		sp_track_popularity(track));
}
*/

/**
 * Print the given album metadata
 *
 * @param  album  The album object
 */

/*
void SpotWorker::print_album(sp_album *album)
{
	printf("  Album \"%s\" (%d)\n",
	       sp_album_name(album),
	       sp_album_year(album));
}
*/

/**
 * Print the given artist metadata
 *
 * @param  artist  The artist object
 */
/*
void SpotWorker::print_artist(sp_artist *artist)
{
	printf("  Artist \"%s\"\n", sp_artist_name(artist));
}
*/

/**
 * Print the given search result with as much information as possible
 *
 * @param  search   The search result
 */
void SpotWorker::print_search(sp_search *search)
{

	printf("Query          : %s\n", sp_search_query(search));
	printf("Did you mean   : %s\n", sp_search_did_you_mean(search));
	printf("Tracks in total: %d\n", sp_search_total_tracks(search));
	puts("");

	/*
	int i;

	for (i = 0; i < sp_search_num_tracks(search) && i < 10; ++i)
		print_track(sp_search_track(search, i));

	puts("");

	for (i = 0; i < sp_search_num_albums(search) && i < 10; ++i)
		print_album(sp_search_album(search, i));

	puts("");

	for (i = 0; i < sp_search_num_artists(search) && i < 10; ++i)
	print_artist(sp_search_artist(search, i));
	
	puts("");
	*/
}
	    
void SpotWorker::streamingStopped()
{
    watchDog->stop();
    printf("Streamstop signal received\n");
    soundSaver->close();
    this->streaming = false;
}

void SpotWorker::playbackStopped()
{
    //this->playing = false;
}

void SpotWorker::saveFile(sp_track *track, SoundSaver::FileType nextFile)
{
    /* Close previous file
     * This should be done by both the soundsaver and the spotworker
     * so this code is probably triple redundant. Wear seatbelts!
     */
    if(soundSaver){
	printf("Closing open file...\n");
	soundSaver->close();
	printf("Closed!\n");
    }
    
    //start a new file
    printf("Extracting filename from track...\n");
    sp_artist *tartist = sp_track_artist(track, 0);
    const char *artistName = sp_artist_name(tartist);
    const char *trackName = sp_track_name(track);
    QString fileName("./");
    fileName += QString(QString().fromUtf8(artistName)) + 
	" - " + QString(QString().fromUtf8(trackName));
    printf("Making new soundsaver...\n");
    soundSaver->open(fileName.toUtf8().data(), nextFile);
    printf("Soundsaver made. returning...\n");
}
 
void SpotWorker::closeFile()
{
    //close previous file
    if(soundSaver){
	printf("Closing open file...");
	soundSaver->close();
	printf("Closed!\n");
    }     
}
 
 /*
   void SpotWorker::ResetCounter()
   {
   frameCounter = 0;
   }
 */

int SpotWorker::getProgress()
{
    return frameCounter/44; //%TODO: dirty constant
}

int SpotWorker::getSongLength()
{
    return totalFrames/44;
}


void SpotWorker::startServer()
{
    tcpServer = new QTcpServer(this);

    if (!tcpServer->listen(QHostAddress::Any, 2718)) {
	/*	QMessageBox::warning(this, tr("Error"),
			      tr("Failed to start server: %1.")
			     .arg(anyWho->errorString()));
	*/
	printf("Epic error!\n");
	return;
    }
    printf("TCP server started!\n");
    connect(tcpServer, SIGNAL(newConnection()), this, SLOT(netConnection()) );
}

void SpotWorker::netConnection()
{
    printf("Connection initiated!\n");
    serverData.state = 0;
    serverData.xfered = 0;
    clientConnection = tcpServer->nextPendingConnection();
    connect(clientConnection, SIGNAL(disconnected()),
	    clientConnection, SLOT(deleteLater()));
    connect(clientConnection, SIGNAL(readyRead()),
	    this, SLOT(rxDataReady()) );
}

void SpotWorker::rxDataReady()
{
    qint64 amount = this->clientConnection->bytesAvailable();
    qint64 handled = 0;
    
    printf("Incoming data! Amount: %lld\n", amount);

    while(handled<amount){
	
	if(serverData.state==0 && amount>=4){
	    char buf[4];
	    qint64 received = clientConnection->read(buf, 4);
	    handled += received;
	    for(int i = 0; i < 4; i++)
		((char *)&serverData.type)[i] = buf[3-i];
	    printf("Packet received. Type: %d\n", serverData.type);
	    serverData.state = 1;
	}
	
	if(serverData.state==1 && amount>=4){
	    char buf[4];
	    qint64 received = clientConnection->read(buf, 4);
	    handled += received;
	    for(int i = 0; i < 4; i++)
		((char *)&serverData.length)[i] = buf[3-i];
	    printf("Packet size: %d\n", serverData.length);
	    if(serverData.length > MAX_PACKET_SIZE)
		printf("Length of packet is crazy. Client is a bastard!");
	    serverData.state = 2;
	}
	if(serverData.state==2){
	    if(serverData.xfered==serverData.length){
		printf("Complete packet received\n");
		parsePacket();
	    }
	    else {
		qint64 received = clientConnection->read((char *)&serverData.data, serverData.length-serverData.xfered);
		handled += received;
		//printf("Packet received. Type: %d\n", serverData.type);
		serverData.xfered += received;
		printf("%lld bytes added to buffer\n", received);
	    }
	}
    }
}

void SpotWorker::parsePacket()
{
    printf("packet type: %d\n", serverData.type);
    printf("Playstop: %d\n", PLAYSTOP);
    printf("Nextblock: %d\n", NEXTBLOCK);
    
    switch(serverData.type){
    case PLAYSTOP:
	playPlayer(!isPlaying());
	break;
    case NEXTBLOCK:
	printf("TODO: send block of audio data\n");
	break;
    default:
	printf("Package had illegal type. Dropping.\n");
    }
    
    serverData.state = 0;
    serverData.xfered = 0;
}
